{"ast":null,"code":"\"use client\";\n\nimport _slicedToArray from \"/Users/feruzxasanov/Downloads/booking samo/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport React, { useEffect } from 'react';\nimport { useMutateObserver } from '@rc-component/mutate-observer';\nimport classNames from 'classnames';\nimport { useToken } from '../theme/internal';\nimport WatermarkContext from './context';\nimport useClips, { FontGap } from './useClips';\nimport useRafDebounce from './useRafDebounce';\nimport useWatermark from './useWatermark';\nimport { getPixelRatio, reRendering } from './utils';\n/**\n * Only return `next` when size changed.\n * This is only used for elements compare, not a shallow equal!\n */\nfunction getSizeDiff(prev, next) {\n  return prev.size === next.size ? prev : next;\n}\nvar Watermark = function Watermark(props) {\n  var _a, _b;\n  var _props$zIndex = props.zIndex,\n    zIndex = _props$zIndex === void 0 ? 9 : _props$zIndex,\n    _props$rotate = props.rotate,\n    rotate = _props$rotate === void 0 ? -22 : _props$rotate,\n    width = props.width,\n    height = props.height,\n    image = props.image,\n    content = props.content,\n    _props$font = props.font,\n    font = _props$font === void 0 ? {} : _props$font,\n    style = props.style,\n    className = props.className,\n    rootClassName = props.rootClassName,\n    _props$gap = props.gap,\n    gap = _props$gap === void 0 ? [100, 100] : _props$gap,\n    offset = props.offset,\n    children = props.children;\n  var _useToken = useToken(),\n    _useToken2 = _slicedToArray(_useToken, 2),\n    token = _useToken2[1];\n  var _font$color = font.color,\n    color = _font$color === void 0 ? token.colorFill : _font$color,\n    _font$fontSize = font.fontSize,\n    fontSize = _font$fontSize === void 0 ? token.fontSizeLG : _font$fontSize,\n    _font$fontWeight = font.fontWeight,\n    fontWeight = _font$fontWeight === void 0 ? 'normal' : _font$fontWeight,\n    _font$fontStyle = font.fontStyle,\n    fontStyle = _font$fontStyle === void 0 ? 'normal' : _font$fontStyle,\n    _font$fontFamily = font.fontFamily,\n    fontFamily = _font$fontFamily === void 0 ? 'sans-serif' : _font$fontFamily;\n  var _gap = _slicedToArray(gap, 2),\n    gapX = _gap[0],\n    gapY = _gap[1];\n  var gapXCenter = gapX / 2;\n  var gapYCenter = gapY / 2;\n  var offsetLeft = (_a = offset === null || offset === void 0 ? void 0 : offset[0]) !== null && _a !== void 0 ? _a : gapXCenter;\n  var offsetTop = (_b = offset === null || offset === void 0 ? void 0 : offset[1]) !== null && _b !== void 0 ? _b : gapYCenter;\n  var markStyle = React.useMemo(function () {\n    var mergedStyle = {\n      zIndex: zIndex,\n      position: 'absolute',\n      left: 0,\n      top: 0,\n      width: '100%',\n      height: '100%',\n      pointerEvents: 'none',\n      backgroundRepeat: 'repeat'\n    };\n    /** Calculate the style of the offset */\n    var positionLeft = offsetLeft - gapXCenter;\n    var positionTop = offsetTop - gapYCenter;\n    if (positionLeft > 0) {\n      mergedStyle.left = \"\".concat(positionLeft, \"px\");\n      mergedStyle.width = \"calc(100% - \".concat(positionLeft, \"px)\");\n      positionLeft = 0;\n    }\n    if (positionTop > 0) {\n      mergedStyle.top = \"\".concat(positionTop, \"px\");\n      mergedStyle.height = \"calc(100% - \".concat(positionTop, \"px)\");\n      positionTop = 0;\n    }\n    mergedStyle.backgroundPosition = \"\".concat(positionLeft, \"px \").concat(positionTop, \"px\");\n    return mergedStyle;\n  }, [zIndex, offsetLeft, gapXCenter, offsetTop, gapYCenter]);\n  var _React$useState = React.useState(),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    container = _React$useState2[0],\n    setContainer = _React$useState2[1]; // Used for nest case like Modal, Drawer\n  var _React$useState3 = React.useState(new Set()),\n    _React$useState4 = _slicedToArray(_React$useState3, 2),\n    subElements = _React$useState4[0],\n    setSubElements = _React$useState4[1]; // Nest elements should also support watermark\n  var targetElements = React.useMemo(function () {\n    var list = container ? [container] : [];\n    return [].concat(list, _toConsumableArray(Array.from(subElements)));\n  }, [container, subElements]);\n  // ============================ Content =============================\n  /**\n   * Get the width and height of the watermark. The default values are as follows\n   * Image: [120, 64]; Content: It's calculated by content;\n   */\n  var getMarkSize = function getMarkSize(ctx) {\n    var defaultWidth = 120;\n    var defaultHeight = 64;\n    if (!image && ctx.measureText) {\n      ctx.font = \"\".concat(Number(fontSize), \"px \").concat(fontFamily);\n      var contents = Array.isArray(content) ? content : [content];\n      var sizes = contents.map(function (item) {\n        var metrics = ctx.measureText(item);\n        return [metrics.width, metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent];\n      });\n      defaultWidth = Math.ceil(Math.max.apply(Math, _toConsumableArray(sizes.map(function (size) {\n        return size[0];\n      }))));\n      defaultHeight = Math.ceil(Math.max.apply(Math, _toConsumableArray(sizes.map(function (size) {\n        return size[1];\n      })))) * contents.length + (contents.length - 1) * FontGap;\n    }\n    return [width !== null && width !== void 0 ? width : defaultWidth, height !== null && height !== void 0 ? height : defaultHeight];\n  };\n  var getClips = useClips();\n  var _React$useState5 = React.useState(null),\n    _React$useState6 = _slicedToArray(_React$useState5, 2),\n    watermarkInfo = _React$useState6[0],\n    setWatermarkInfo = _React$useState6[1]; // Generate new Watermark content\n  var renderWatermark = function renderWatermark() {\n    var canvas = document.createElement('canvas');\n    var ctx = canvas.getContext('2d');\n    if (ctx) {\n      var ratio = getPixelRatio();\n      var _getMarkSize = getMarkSize(ctx),\n        _getMarkSize2 = _slicedToArray(_getMarkSize, 2),\n        markWidth = _getMarkSize2[0],\n        markHeight = _getMarkSize2[1];\n      var drawCanvas = function drawCanvas(drawContent) {\n        var _getClips = getClips(drawContent || '', rotate, ratio, markWidth, markHeight, {\n            color: color,\n            fontSize: fontSize,\n            fontStyle: fontStyle,\n            fontWeight: fontWeight,\n            fontFamily: fontFamily\n          }, gapX, gapY),\n          _getClips2 = _slicedToArray(_getClips, 2),\n          nextClips = _getClips2[0],\n          clipWidth = _getClips2[1];\n        setWatermarkInfo([nextClips, clipWidth]);\n      };\n      if (image) {\n        var img = new Image();\n        img.onload = function () {\n          drawCanvas(img);\n        };\n        img.onerror = function () {\n          drawCanvas(content);\n        };\n        img.crossOrigin = 'anonymous';\n        img.referrerPolicy = 'no-referrer';\n        img.src = image;\n      } else {\n        drawCanvas(content);\n      }\n    }\n  };\n  var syncWatermark = useRafDebounce(renderWatermark);\n  // ============================= Effect =============================\n  // Append watermark to the container\n  var _useWatermark = useWatermark(markStyle),\n    _useWatermark2 = _slicedToArray(_useWatermark, 3),\n    appendWatermark = _useWatermark2[0],\n    removeWatermark = _useWatermark2[1],\n    isWatermarkEle = _useWatermark2[2];\n  useEffect(function () {\n    if (watermarkInfo) {\n      targetElements.forEach(function (holder) {\n        appendWatermark(watermarkInfo[0], watermarkInfo[1], holder);\n      });\n    }\n  }, [watermarkInfo, targetElements]);\n  // ============================ Observe =============================\n  var onMutate = function onMutate(mutations) {\n    mutations.forEach(function (mutation) {\n      if (reRendering(mutation, isWatermarkEle)) {\n        syncWatermark();\n      }\n    });\n  };\n  useMutateObserver(targetElements, onMutate);\n  useEffect(syncWatermark, [rotate, zIndex, width, height, image, content, color, fontSize, fontWeight, fontStyle, fontFamily, gapX, gapY, offsetLeft, offsetTop]);\n  // ============================ Context =============================\n  var watermarkContext = React.useMemo(function () {\n    return {\n      add: function add(ele) {\n        setSubElements(function (prev) {\n          var clone = new Set(prev);\n          clone.add(ele);\n          return getSizeDiff(prev, clone);\n        });\n      },\n      remove: function remove(ele) {\n        removeWatermark(ele);\n        setSubElements(function (prev) {\n          var clone = new Set(prev);\n          clone.delete(ele);\n          return getSizeDiff(prev, clone);\n        });\n      }\n    };\n  }, []);\n  // ============================= Render =============================\n  return /*#__PURE__*/React.createElement(\"div\", {\n    ref: setContainer,\n    className: classNames(className, rootClassName),\n    style: Object.assign({\n      position: 'relative'\n    }, style)\n  }, /*#__PURE__*/React.createElement(WatermarkContext.Provider, {\n    value: watermarkContext\n  }, children));\n};\nif (process.env.NODE_ENV !== 'production') {\n  Watermark.displayName = 'Watermark';\n}\nexport default Watermark;","map":null,"metadata":{},"sourceType":"module"}